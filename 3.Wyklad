Liniowe statyczne struktury danych 
----------------------------------------

Najważniejszymi statycznymi strukturami danych w C są:
- Tablica [Array] 
    - tablice sekwencyjne 
    - napisy 
    - kolejki 
    - stosy 
- struct 
- union

---------------------------------------
TABLICA - Tablice seknwencyjne 
---------------------------------------

Ciąg zmiennych tego samego typu (liczb, znaków, innych typów prawidłowych dla kompilatora)

Pojedyncza zmienna w tablicy nazywana jest elementem tablicy 

Do wszystkich zmiennych w tablicy odwołujemy się poprzezz tę samą nazwę wykorzystując indeks elementu tablicy

W języku C domyślnym indeksem tablciy są liczby naturalne z zerem 

---

W praktyce najczęściej spotykamy się z tablicami 
- jednowymiarowymi (wektory)
- dwuwymiarowymi (macierze)
- trójwymiarowymi (prostopadłościany)

Często tablica używa się do określenia implementacji macierzy 

Liczna grupa metod numerycznych wykorzystuje pojęcie tablicy, ciągu, seknwecji liczb 

--------------------------------------
WEKTORY - TABLICE JEDNOWYMIAROWE 
--------------------------------------

typ_elementów  - każdy z elementó tablicy jest typu typ_elementów 
nazwa tablicy - dostęp do każdego z elementó tablicy jest realizowany poprzez jej nazwę 
[rozmiar] - liczba całkowita w nawiasach kwadratowych, rozmiar 

Zmienne i stałę typu tablicowego deklarujemy w części deklaracyjej programu czy pod programów 

--------------------------------------
TYP WSKAŹNIKOWY - TABLICE JEDNOWYMIAROWE 
--------------------------------------

Specjalny typ danych. 
Zmienna typu wskaźnikowego przechowuje adres do innej zmiennej w pamięci programu.
Tak jak inne zmienne, należy go zadeklarować oraz zainicjalizować przed pierwszym użyciem.
Wskaźniki mają okreslonąspecjalną arytmetykę, dzięki której można w stosunkowo łątwy sposób operaowaćć na adresach w pamięci operacyjnej 
Unarny jenoargumentowy operator * oznacza adresowanie i daje w wyniku zmienną lub funkcję wskazywaną przez argument 


--------------------------------------
TABLICE JEDNOWYMIAROWE 
--------------------------------------

indeks jest liczony od zera do wartości -1 

Pięciopozycyjna tablica liczb całkowwitych: int tab[5];

Zawiera przypadkowe dane, zaleca się inicjalizować wartości wszystkich elementów 

---

Wypełnienie tablicy z wykorzystaniem pętrli for 

int tab[5];
int j; 
for (j=0; j<5; j++) {
    tab [j] = j;
}

// tab[0] = 0 ... tab[4] = 4

---

Inicjalizować tablicę można za pomocą pętli for 

Można również wczyytać wartość elementó przy pomocy funkcji scanf();

Zainicjowane wartości w tablicy w postaci wyliczenia listy wartości:

typ_elementów nazwa_tablicy [rozmiar] = {lista wartości}

char znaki[5] = {'A','B','C','D','E'}

int cyfry[5] = {1,2,5} //  {1,3,5,0,0}

int cyfry[5] = {[1..3]=2}; // {0,2,2,2,0}

int cygry[5] = {}; // {0,0,0,0,0}

---

dobry zwyczaj to jawne wypełnienie tablicy wartościami  
int tab[100];
int j;
for (j=0;j<100;j++) { tab[j] = 0}

---

Przykład kodu z wczytaniem elementów do tablicy i ich wypisanie na ekranie 
#include <stdio.h>
int moja_tab[8]
int j; 
main() {
    for(j=0;j<8;j++) {
        scanf("%d, &moja_tab[j]);
        printf("moja_tab[ %d] == %d\n", j, moja_tab[j]);
    }
    return 0;
}

--- 

Jeśli nie wiemy ile będzie mieć tablica możemy użyc deklaracji bez rozmiaru 

typ_elementów nazwa_tablicy[] = {}

int calkowite[] = [1,2,-5]
float rzeczywiste[] = {-12.23}
unsigned int naturalne[] = {0,2,10}

---

W inicjalizacji wartości tablic po ostatnim elemencie tablicy może występować przecinek
int tab[100] = {3,5}; //  {3, 5, 0}

Możliwe jest posługiwanie się sizeof do wyliczenia rozmiaru 
int i;
for (i=0; i<sizeof tab; i++) {
    printf("%d", tab[i]);
}

-------------------------------------------------
Przepisywanie zawartości z tablicy do innej tablicy 
-------------------------------------------------

int zrodlo[5] = {0, 1, 2, 3, 4}
int wynik[5];

int i=7, j;
j = i; 

for (i=0; i<5; i++){
    wynik[i] = zrodlo[i]
}

---
Wyliczenie wartości średniej elementów tablicy 

#include <stdio.h>
int zakres = 20;
int tablica[zakres];
int i, suma;
float srednia; 

main() {
    srednia = 0.0
    suma = 0;
    for (i=0;i<zakres' i++) {
        printf("Podaj: tablica [%d] = ", i);
        scanf("%d"m &tablica[i]);
        printf(\n);
    }
    for (i=0; i<zakres;i++) {
        suma = suma + tablica [i];
    }
    srednica = suma / zakres 
    printf("Wartość %f\n', srednia);
    return 0;
}

---

Wykorzystanie nieskończonej pętli for :

#include <stdio.h>
unsigned long suma;
unsigned int liczba;
unsigned int tablica[100];
int licznik;
main ( )
{
   licznik = 0;
   suma = 0;
   liczba = 1;
   for( ; ; )    /*nieskończona pętla for - można ją przerwać wyłącznie poleceniem: break */
   {
      if ((liczba == 0) || (licznik == 100))
        {
           break;
        }
      else
         {
            printf(”Podaj do sumy liczbę dodatnią z zakresu: 1 - 65535.”);
            printf(”Podaj wartość 0, aby wcześniej zakończyć działanie programu.\n”);
            scanf(”%u”, &liczba);  /*wczytanie liczby z klawiatury*/
            tablica[licznik] = liczba; licznik++;
            suma = suma + liczba;
        } 
   }
   printf(”Wczytano %d liczb. Ich suma wynosi: %lu\n”; liczba, suma);
   return 0;
}

---------------------------
TABLICE WIELOWYMIAROWE
---------------------------

typ_elementów nazwa [wymiar1]...[wymiar2]

Deklaracja macierzy liczb rzeczywistych 

float macierz_R [4][3];

-----------------------
inicjowanie elementów macierzy
-----------------------

Podwójna pętla:

float macierz_R[4][3]
    int i, j;
    for(i=0;i<4;i++){
        for (j=0;j<3; j++){
            macierz_R[i][j] = 0.0;;
        }
    }

Jawnie ustalenie wszystkich wartości:

float macierz_R[2][2]= {
    0.0, 1.0,
    0.2, 3.0
};

Selektywne wstawianie wartości do tablicy:
macierz_R[2][3] = 1.0;

---

Przykład macierzy liczb całkowitych:
wartość iloczynu indeksów wierszy i kolumn poszczególnych elementów macierzy

#include <stduio.h>
int macierz[4][5];
main() {
    for(i=0;i<4;i++) {
        for(j=0;j<5;j++){
            macierz[i][j] = i*j
        }
    }
    for(i=0;i<4;i++) {
        for(j=0;j<5;j++){
            printf("%d", macierz[i][j]);

        }
        printf("\n");
    }
    return 0
}

-----------------
napisy - tablice znaków 
-----------------

Napis, string jest najczęściej jednowymiarową tablicą wykorzystywnaną w jężyku C 
C - nie ma string 

Każdy napis w C jest jednowymiarową tablicą znaków, która automatycznie jest zamykana specjalnym elementem zerowym (null) 

char nazwa_napisu[rozmiar]
char bo każdy z elementów napisu jest typu znakowego 

char greeting[6] = {"H','e','l','l','o','\0'};
char greeting[] = 'Hello';

---

wczytanie napisu i wypisanie go pojedynczymi znakami 

#include <stdio.h>
char napis[80];
int i;

main() {
    printf("Wprowadz napis nie wiekszy niz 80 znakow:");
    gets(napis);
    for(i=0; napis[i]; i++){
        printf("%c", napis[i]);
    }
    return 0
}

gets - czyta linie i umieszcza ją w tablicy znakowej wskazywanej przez napis
napis[i] - dziala dopóki nie ma 0, czyli do ostatniego znaku 


--- 

bez pętli 

#include <stdio.h> 
char napis[80];

main() {
    printf('Wprowadz napis:");
    gets(napis);
    printf(napis);
    return 0;
}

printf - wykrywa automatycznie znak \0

-----------------
funkcje operujące na napisach
-----------------

<stdio.h>

- gets(napis) - wczyta napisu, enter jest zamieniany na null 
- scanf() - kończy gdy napotka whitespace lub newline 
- printf(napis,...) wypisanie napisu 

<string.h>

- strcpy(wynik,zrodlo) - kopiuje zrodlo do wyniku 
- strcat(wynik, zrodlo) - dołączą źródło do wyniku 
- strcmp(napis1, napis2) - porównanie napisów 
0 - identyczne
< 0 - napis1 mniejszy 
> 0 - napis2 większy 
-strlen(napis) - długość napisu bez null 

-----------------
inicjowanie napisów 
-----------------

Kilka wariantów 

char imie1 [] = "Nowak";
char imie2 [6] = "Nowak"; - 6 znak  to \0 - cudzysłów automatycznie daje \0
char imie2 [6] = {'N','O','W','A','K','\0'};

w każdym z wariantów mamy 
sizeof(imie) = 6
strlen(imie) = 5

char imie1 [] = "";  1 0 
char imie2 [6] = ""; 6 0 
char imie3 []={};    0 0

---

Napis inicjowany jako tablica znaków bez deklaracji rozmiaru 

char komunikat[] = "wcisnij klawisz";
char imie[] = "Anna";

char lista_przedmiotowp[][40] = {
    "Przedmiot 1",
    "Przedmiot 2",
}

---

pętla wyświetlająca listę przedmiotów pojedynczymi znakami

int i,j; 

for(i=0; lista_przedmiotow[i][0];i++){
    for (j=0;lista_przedmiotow[i][j];j++]){
        printf("%c", lista_przedmiotow[i][j]);
    }
    printf("\n");
}

------------------------
STRUKTURY 
------------------------

Struktura to złożony typ danych, grupujący powiązane ze sobą dane różnych typów w jednym obszarze pamięci o wspólnym typie 

Skłądowe struktury tzw pola mają swoje unikatowe identyfikatory (nazwy), poprzez które otrzymujemy dostęp do danego pola  

Pola struktur i unii mogą być inicjowane w miejscu ich deklaracji poprzez listę inicjacyjną 

Wartość na liście inicjacyjnej, muszą byćzgodne z typami danych pól struktury oraz podane w kolejności deklaracji pól w strukturze 

struct ts_osoba {
    char nazwisko[15];
    char imie[15];
    long PESEL;
    unsigned rok, miesiac, dzien; 
}

------------------
inicjowanie struktur
------------------

#include <stdio.h>
#include <string.h>

struct ts_osoba os; 

int main() {
    os.PESEL = 99010127635;
    os.rok=1999;
    os.miesiac=01;
    os.dzien=01;

    scanf("%u", &os.rok);  // pobranie z klawiatury wartości roku 
    return 0;
}

---

jeśli na liście nicjacyjnej jest mniej stałych niż pól struktury to w przypadku struktur statycznych pozostałe składowe są inicjowane wartościami zerowymi 

W przypadku struktur automatycznych inicjalizacja zależy od kompilatora - najczęściej są inicjowane wartościami zerowymi 

#include <stdio.h> 
struct ts_osoba os3={}
struct ts_osoba os3={"Cabacki"} // struktura statyczna 

int main() {
    struct ts_osoba os4={.imie="Adam",rok=1999};
    printf("naz=%s pesel=%1d", os3.nazwisko, os3.imie, os3.PESEL);

    // Otrzymamy naz = Cabacki im= pesel=0

    printf("naz=$s im=%s rok=%1d", os4.nazwisko, os4.imie, os4.rok);

    // otrzymamy naz= im=Adam rok=1999
    return 0;
}

---------------------------
rezerwacja pamięci dla struktur 
---------------------------

pola struktury sąumieszczane w pamięci zgodnie z kolejnością w deklaracji;
każde pole struktury zajmuje osoby obszar pamięci;
rozmiar struktury jest zawsze większy lub równy sumie rozmiarów jej skłądowych;
rozmiar jest większy, gdy kompilator wyrównuje pamięć dla pól dla granicy słowa (2,4,8 bajtów) - zapewnia szybszy dostęp do mikroprocesorowi do pól struktury 

struct ts osoba {
    char nazwisko[15];
    char imie[15];
    long PESEL; 
    unsigned rok, miesiac, dzien;
} os; 

\\ size=46 == 15, 15, 4,4,4,4 

printf("size=%d", sizeof(struct ts_osoba)); 

adresy pól:
printf("adr nazwisko=%p\n", &os.nazwisko[0]);
printf("adr imie=%p\n",&os.imie[0]);
printt("adr PESEL=%p\n", &os.PESEL)

---

------------------------
operatory dla struktur 
------------------------

Dla zmiennych typu struct zdefiniowany jest tylko operator przypisania "="
Wszystkie inne operacje wykonuje się na polach struktury;
Poprawnie wykona się kopiowanie zawartości struktur między zmiennymi:

struct ts_osoba os1={.rok=1999};
struct ts_osoba os2=os1; 

Niedozwolone jest porównywanie if (os1 == os2)

---------------------
struktury zagnieżdżone
---------------------

Składowymi struktur mogą być również inne struktury 

Odwołanie do pola struktury, która sama jest skłądową innej struktury odbywa sięz wykorzystaniem dwóch kropek 

struct ts_data {
    unsigned rok, miesiac, dzien;
};

struct ts_osoba {
    char nazwisko[15];
    char imie[15];
    long PESEL; 
    struct ts_data data;
} os; 
os.data.rok=1999

----------------------------
deklaracje unii 
----------------------------

Rzadki typ to unia 

podobna do struktury, ma na celu zmniejszenie zapotrzebowania na pamięć, nieraz wykoszystywane tylko jedno pole skłądowe 

jest zapisana pod jednym adresem, adresu używanego pola 

union <nazwa> {
    <typ1> <nazwa>;
} <zmienna>;

---------------------
inicjowanie unii
---------------------

Unia inicjowana w deklaracji, to tylko wartość w kolejności pól, można podać wartość wybranego pola 

union znak_lub_liczba {
    char znaki[4];
    long liczba;
} zl={"abcd};

---

przy danych innego typu wykonywana jest automatyczna konwersja 

#include <stdio.h> 

union znaki_lub_liczba z11={65}

int main(void) {
    union znaki_lub_liczba z12={.liczba=65.66};

    printf("znak=%c, z11.znaki[0]);
    printf("znak=%c, z12.znaki[0]);

    printf("znak=%d, z11.liczba);
    printf("znak=%d, z12.liczba);

    return 0;
}

-----------------------
rezerwacja pamięci dla unii 
-----------------------

Pola unii zajmują wspólny obszar pamięci - rozmiar unii jest równy rozmiarowi jej największej składowej.
Wszystkie składowe unii mają ten sam adres  

union znaki_lub_liczba {
    char znaki[4];
    long liczba;
} z;

printf("size=%d",sizeof(z)); // 8 (max, 4,8)
printf("adr z.znaki=%p\n", &z.znaki[0]); ten sam adres 
printf("adr z.liczba=%p\n", &z.liczba);  ten sam adres

---------------------------
liniowe struktury danych 
---------------------------

tablice i napisy stanowią jedne z przykładów liniowych struktur danych 

możemy wyróżnić:
- napisy 
- tablice seknwencyjne 
- kolejki 
- stosy 

- lsity dynamiczne 
- tablice rzadkie 
- tablice rozproszone 

----------------
kolejki
----------------

queue - jest strukturą danych wykorzystywaną najczęściej jako bufor przechowujący dane określonych typów;

Dyscypliny kolejek 
- FIFO (First in First Out) - pierwszy element wchodzący staje się pierwszych wychodzącym
- LIFO (Last in First Out) - ostatni wychodzący staje siępierwszym wychodzącym (stos)
- kolejki priorytetowe - o uwzględnienie wartości priorytetów przechowywanych danych 
- Round-Robin - cykliczna kolejka z dyscylpiną czasu obsługi komunikatu przechowywanego w kolejsce (systemu operacyjne, sieci komputerowe)

LIFO: 
d1 > d2 d1 > d3 d2 > d1 

Odłożenie na stos - push 
pobranie ze stosu - pop 

---
int Stos[N];
int top = -1;

void push(int item) {
    if(top >= N-1) {
        printf("\nStos przepełniony")
    } else {
        top = top + 1;
        Stos[top] = item;
    }
}

int pop() {
    int item = -1;
    if(top == -1){
        printf("\nStos pusty, stack underflow")
    } else {
        item = Stos[top]
        Stos[top]=-1;
        top= top-1;
    }
    return(item);
}

---

void main() {
      int item, operacja, petla = 1;
      while(petla == 1) {
            printf("\n1.Operacja Push\n");
            printf("\n2.Operacja Pop\n");
            printf("\nWybierz operację: ");
            scanf("%d",&operacja);
            switch(operacja) {
                  case 1:
                        printf("\nWprowadź wartość odkładanej liczby: ");
                        scanf("%d",&item);
                        push(item);
                        break;
                  case 2:
                        item = pop();
                        if(item != -1);
                        {
                            printf("\nWartość pobranej liczby wynosi: %d\n",item);
                        }                       
                        break;
                  default:
                        printf("\nNieoprawny wybór operacji – powtórz wybór: \n");
                        break;
            }
            printf("\nKontynuwoać? (1-tak / inny znak-nie): ");
            scanf("%d",&petla);
      }
}

------------------
ALGORYTMY SORTOWANIA TABLIC SEKNWECYJNYCH 
------------------

- sortowanie przez wstawianie (insertion sort)
- sortowanie przez wybieranie (selekcję - selection sort)
- sortowanie przez zamianę (exchange sort, bubble sort)
- sortowanie mieszane (shake sort)

Klucz: 44 55 12 42 94 18 06 67

-----------
INSERTION SORT - sortowanie przez wstawianie  
-----------

Kolejne elementy ciągu od bieżącej pozycji do końca są przesuwane do początku na odpowiednie miejsce (rosnąco)

44    "55"   12     42    94     18    06    67
44    |55|   "12"   42    94     18    06    67
|12|  `44`   `55`  "42"   94     18    06    67 
12    |42|   '44'  '55'   "94"   18    06    67
12    42     44    55     |94|   "18"  06    67
12    |18|   '42'  '44'   '55'   '94'  "06"  67
|06|  '12'   '18'  '42'   '44'   '55'  '94'  67
06    12     18    42     44     55   |67|   '94'

#include <stdio.h> 
int main()
{
  int n, wektor[100], licznik, iter, temp; 
  printf("Podaj liczbe elementow do sortowania\n");
  scanf("%d", &n); 
  printf("Wprowadź %d liczb całkowitych\n", n); 
  for (licznik = 0; licznik < n; licznik++) {
    scanf("%d", &wektor[licznik]);
  } 
  for (licznik = 1 ; licznik < n; licznik++) {
    iter = licznik; 
    while ( iter > 0 && wektor[iter] < wektor[iter-1]) {
      temp           = wektor[iter];
      wektor[iter]   = wektor[iter-1];
      wektor[iter-1] = temp; 
      iter--;
    }
  } 
  printf("Liczby posortowane rosnąco:\n"); 
  for (licznik = 0; licznik < n; licznik++) {
    printf("%d\n", wektor[licznik]);
  } 
  return 0;
}


--------------
SELECTION SORT 
--------------

Szukanie elementu właściwego - najmniejszego w ciągu od bieżącej pozycji do końca, zamiana miejscami

44      55      12      42      94      18    '06'    67
|06|    55      '12'    42      94      18    "44"    67
06      |12|    "55"    42      94      '18'  44      67
06      12      |18|    42      94      "55"  '44'    67

#include <stdio.h> 
int main()
{
   int wektor[100], n, licznik, iter, pozycja, temp;
   printf("Podaj liczbe elementow do sortowania\n");
   scanf("%d", &n); 
   printf("Wprowadź %d liczb całkowitych\n", n); 
   for ( licznik = 0 ; licznik < n ; licznik++ )
      scanf("%d", &wektor[licznik]); 
   for ( licznik = 0 ; licznik < ( n - 1 ) ; licznik++ )   {
      pozycja = licznik; 
      for ( iter = licznik + 1 ; iter < n ; iter++ )      {
         if (wektor[pozycja] > wektor[iter] )
            pozycja = iter;
      }
      if ( pozycja != licznik )
      {
         temp = wektor[licznik];
 	   wektor[licznik] = wektor[pozycja];
	   wektor[pozycja] = temp;
      }
   } 
   printf("Liczby posortowane rosnąco:\n"); 
   for ( licznik = 0 ; licznik < n ; licznik++ )
      printf("%d\n", wektor[licznik]); 
   return 0;



